<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›´æ¥ASRæµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .button {
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        .button.success { background-color: #28a745; color: white; }
        .button.danger { background-color: #dc3545; color: white; }
        .button.primary { background-color: #007bff; color: white; }
        .button:disabled { background-color: #6c757d; cursor: not-allowed; }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
        }
        .result {
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-weight: bold;
            font-size: 18px;
        }
        .result.success { background-color: #d4edda; color: #155724; }
        .result.error { background-color: #f8d7da; color: #721c24; }
        .result.warning { background-color: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ ç›´æ¥ASRæµ‹è¯•</h1>
        <p><strong>ç›®æ ‡ï¼š</strong>ç»•è¿‡æ‰€æœ‰å¤æ‚é€»è¾‘ï¼Œç›´æ¥æµ‹è¯•æœ€åŸºæœ¬çš„å½•éŸ³å’Œè¯†åˆ«</p>
        
        <div class="controls">
            <button id="recordBtn" class="button success">ğŸ¤ å½•éŸ³5ç§’</button>
            <button id="testWavBtn" class="button primary">ğŸ“ æµ‹è¯•WAVæ–‡ä»¶</button>
            <button id="testTextBtn" class="button primary">ğŸ“ æµ‹è¯•å›ºå®šæ–‡æœ¬</button>
        </div>
        
        <div id="result" class="result">ç­‰å¾…æµ‹è¯•...</div>
        
        <div class="container">
            <h3>ğŸ“ æµ‹è¯•æ—¥å¿—</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        const recordBtn = document.getElementById('recordBtn');
        const testWavBtn = document.getElementById('testWavBtn');
        const testTextBtn = document.getElementById('testTextBtn');
        const result = document.getElementById('result');
        const log = document.getElementById('log');
        
        function addLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            log.appendChild(logEntry);
            log.scrollTop = log.scrollHeight;
            console.log(message);
        }
        
        function updateResult(text, type = '') {
            result.innerHTML = text;
            result.className = 'result ' + type;
        }
        
        // åˆ›å»ºä¸€ä¸ªæœ€å°çš„WAVæ–‡ä»¶ï¼ˆ1ç§’ï¼Œ16kHzï¼Œå•å£°é“ï¼Œé™éŸ³ï¼‰
        function createMinimalWav() {
            const sampleRate = 16000;
            const duration = 1; // 1ç§’
            const samples = sampleRate * duration;
            const buffer = new ArrayBuffer(44 + samples * 2);
            const view = new DataView(buffer);
            
            // WAVæ–‡ä»¶å¤´
            let offset = 0;
            
            // RIFF
            view.setUint32(offset, 0x46464952, false); offset += 4; // "RIFF"
            view.setUint32(offset, 36 + samples * 2, true); offset += 4; // æ–‡ä»¶å¤§å°
            view.setUint32(offset, 0x45564157, false); offset += 4; // "WAVE"
            
            // fmt
            view.setUint32(offset, 0x20746d66, false); offset += 4; // "fmt "
            view.setUint32(offset, 16, true); offset += 4; // fmt chunk size
            view.setUint16(offset, 1, true); offset += 2; // PCM format
            view.setUint16(offset, 1, true); offset += 2; // 1 channel
            view.setUint32(offset, sampleRate, true); offset += 4; // sample rate
            view.setUint32(offset, sampleRate * 2, true); offset += 4; // byte rate
            view.setUint16(offset, 2, true); offset += 2; // block align
            view.setUint16(offset, 16, true); offset += 2; // 16 bits per sample
            
            // data
            view.setUint32(offset, 0x61746164, false); offset += 4; // "data"
            view.setUint32(offset, samples * 2, true); offset += 4; // data size
            
            // ç”Ÿæˆç®€å•çš„éŸ³é¢‘æ•°æ®ï¼ˆ440Hzæ­£å¼¦æ³¢ï¼‰
            for (let i = 0; i < samples; i++) {
                const sample = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.3;
                const intSample = Math.round(sample * 32767);
                view.setInt16(offset, intSample, true);
                offset += 2;
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        recordBtn.addEventListener('click', async () => {
            try {
                addLog('å¼€å§‹5ç§’å½•éŸ³æµ‹è¯•...');
                updateResult('æ­£åœ¨å½•éŸ³...', '');
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mediaRecorder = new MediaRecorder(stream);
                const chunks = [];
                
                mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(chunks, { type: mediaRecorder.mimeType });
                    addLog(`å½•éŸ³å®Œæˆ: ${audioBlob.size} bytes, ${mediaRecorder.mimeType}`);
                    
                    // ç›´æ¥å‘é€åŸå§‹å½•éŸ³
                    await testRecognition(audioBlob, 'åŸå§‹å½•éŸ³');
                    
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                recordBtn.disabled = true;
                
                // 5ç§’åè‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    mediaRecorder.stop();
                    recordBtn.disabled = false;
                    addLog('å½•éŸ³å·²åœæ­¢');
                }, 5000);
                
            } catch (error) {
                addLog(`å½•éŸ³å¤±è´¥: ${error.message}`);
                updateResult(`å½•éŸ³å¤±è´¥: ${error.message}`, 'error');
            }
        });
        
        testWavBtn.addEventListener('click', async () => {
            addLog('æµ‹è¯•ç”Ÿæˆçš„WAVæ–‡ä»¶...');
            const wavBlob = createMinimalWav();
            addLog(`ç”ŸæˆWAVæ–‡ä»¶: ${wavBlob.size} bytes`);
            await testRecognition(wavBlob, 'ç”Ÿæˆçš„WAV');
        });
        
        testTextBtn.addEventListener('click', async () => {
            addLog('æµ‹è¯•å›ºå®šæ–‡æœ¬è¯†åˆ«...');
            
            try {
                // ç›´æ¥è°ƒç”¨åç«¯APIæµ‹è¯•
                const response = await fetch('/api/voice_recognition', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        test: true,
                        text: 'ä½ å¥½ä¸–ç•Œ'
                    })
                });
                
                const result = await response.text();
                addLog(`åç«¯å“åº”: ${result}`);
                
                if (response.ok) {
                    updateResult('åç«¯APIæ­£å¸¸å“åº”', 'success');
                } else {
                    updateResult('åç«¯APIå“åº”å¼‚å¸¸', 'error');
                }
                
            } catch (error) {
                addLog(`APIæµ‹è¯•å¤±è´¥: ${error.message}`);
                updateResult(`APIè¿æ¥å¤±è´¥: ${error.message}`, 'error');
            }
        });
        
        async function testRecognition(audioBlob, source) {
            try {
                addLog(`å¼€å§‹æµ‹è¯•${source}è¯†åˆ«...`);
                updateResult(`æ­£åœ¨è¯†åˆ«${source}...`, '');
                
                const formData = new FormData();
                const extension = audioBlob.type.includes('wav') ? 'wav' : 'webm';
                const audioFile = new File([audioBlob], `test.${extension}`, {
                    type: audioBlob.type
                });
                formData.append('audio', audioFile);
                
                addLog(`å‘é€æ–‡ä»¶: ${audioFile.name}, ${audioFile.size} bytes, ${audioFile.type}`);
                
                const response = await fetch('/api/voice_recognition', {
                    method: 'POST',
                    body: formData
                });
                
                addLog(`HTTPçŠ¶æ€: ${response.status}`);
                
                const responseText = await response.text();
                addLog(`åŸå§‹å“åº”: ${responseText}`);
                
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    addLog(`JSONè§£æå¤±è´¥: ${e.message}`);
                    updateResult(`å“åº”æ ¼å¼é”™è¯¯`, 'error');
                    return;
                }
                
                if (data.success) {
                    const text = data.text || '';
                    addLog(`è¯†åˆ«æˆåŠŸ: "${text}"`);
                    
                    if (text.includes('æˆ‘ä¸çŸ¥é“') || text.includes('ä¸çŸ¥é“')) {
                        updateResult(`âš ï¸ ä»ç„¶è¿”å›"æˆ‘ä¸çŸ¥é“": ${text}`, 'warning');
                        addLog('âŒ é—®é¢˜ä¾ç„¶å­˜åœ¨ï¼');
                        
                        // è¯¦ç»†åˆ†æ
                        addLog('ğŸ” å¯èƒ½çš„åŸå› :');
                        addLog('   1. éŸ³é¢‘æ•°æ®ç¡®å®æ— æ•ˆæˆ–æŸå');
                        addLog('   2. ç™¾åº¦APIé…ç½®é—®é¢˜');
                        addLog('   3. éŸ³é¢‘æ ¼å¼ä»ç„¶ä¸å…¼å®¹');
                        addLog('   4. å½•éŸ³ç¯å¢ƒå™ªéŸ³è¿‡å¤§');
                        addLog('   5. è¯´è¯å†…å®¹ä¸å¤Ÿæ¸…æ™°');
                        
                    } else if (text.trim() === '') {
                        updateResult('âš ï¸ è¯†åˆ«ç»“æœä¸ºç©º', 'warning');
                        addLog('å¯èƒ½æ˜¯é™éŸ³æˆ–éŸ³é¢‘æ— æ•ˆ');
                    } else {
                        updateResult(`âœ… è¯†åˆ«æˆåŠŸ: "${text}"`, 'success');
                        addLog('ğŸ‰ è¯†åˆ«æ­£å¸¸ï¼é—®é¢˜å·²è§£å†³');
                    }
                    
                    if (data.confidence) {
                        addLog(`ç½®ä¿¡åº¦: ${data.confidence}`);
                    }
                } else {
                    addLog(`è¯†åˆ«å¤±è´¥: ${data.error}`);
                    updateResult(`è¯†åˆ«å¤±è´¥: ${data.error}`, 'error');
                    
                    if (data.error_code) {
                        addLog(`é”™è¯¯ç : ${data.error_code}`);
                    }
                }
                
            } catch (error) {
                addLog(`æµ‹è¯•å¤±è´¥: ${error.message}`);
                updateResult(`æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // åˆå§‹åŒ–
        addLog('ğŸ¯ ç›´æ¥ASRæµ‹è¯•å·¥å…·å·²åŠ è½½');
        addLog('ğŸ“‹ æµ‹è¯•é€‰é¡¹:');
        addLog('   1. "å½•éŸ³5ç§’" - å½•åˆ¶çœŸå®è¯­éŸ³æµ‹è¯•');
        addLog('   2. "æµ‹è¯•WAVæ–‡ä»¶" - ä½¿ç”¨ç”Ÿæˆçš„æ ‡å‡†WAVæ–‡ä»¶');
        addLog('   3. "æµ‹è¯•å›ºå®šæ–‡æœ¬" - æµ‹è¯•åç«¯APIè¿æ¥');
        addLog('');
        addLog('ğŸ’¡ å»ºè®®å…ˆæµ‹è¯•"æµ‹è¯•WAVæ–‡ä»¶"ç¡®è®¤æ ¼å¼æ˜¯å¦æ­£ç¡®');
    </script>
</body>
</html>
